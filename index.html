<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dragon vs Knight</title>
  <meta name="build-time" content="20240403-forcereload">
  <style>
    body { 
      margin: 0; 
      background-color: #000000; 
      overflow: hidden;
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #loading progress {
      width: 70%;
      margin-top: 20px;
    }
  </style>
  <!-- Inline favicon to avoid 404 -->
  <link rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIKCggCCgoIAgoKCAIKCggCCgoIAgoKCAIKCggCCgoIAgoKCAIKCggCCgoIAAAAAAAAAAAAAAAAAAAAAAOTr7wKCgoJYgoKCnIKCgraCgoK2goKCtoKCgraCgoK2goKCtoKCgraCgoKcgoKCWOTr7wIAAAAAAAAAAAAAAAAAAAAAnJeRqoKCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+cl5GqAAAAAAAAAAAAAAAAAAAAALh7P/+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/uHs//wAAAAAAAAAAAAAAAAAAAAC4ez//goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/7h7P/8AAAAAAAAAAAAAAAAAAAAAuHs//4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+4ez//AAAAAAAAAAAAAAAARo3lZKlvMf+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/qW8x/0aN5WQAAAAAAAAAAEaN5f9Xn///qW8x/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/qW8x/1ef//9GjeX/AAAAAAAAAABGjeX/V5///6lvMf+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/6lvMf9Xn///Ro3l/wAAAAAAAAAARo3l/1ef//+pbzH/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+pbzH/V5///0aN5f8AAAAAAAAAAEaN5WRGjeX/Ro3l/7h7P/+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+4ez//Ro3l/0aN5f9GjeVkAAAAAAAAAAAAAAAAAAAAALh7P/+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/7h7P/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuHs//4KCgv+CgoL/goKC/4KCgv+CgoL/goKC/4KCgv+CgoL/uHs//wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4ez//nJeRqoKCgliCgoKcgoKCtoKCgraCgoK2goKCnIKCgljk6+8CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=">
</head>
<body>
  <div id="loading">
    <h2>Loading Dragon Knight...</h2>
    <progress id="progress-bar" value="0" max="100"></progress>
    <p id="loading-status">Initializing...</p>
  </div>

  <!-- Load Three.js and dependencies -->
  <script src="https://unpkg.com/three@0.175.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.175.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.175.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.175.0/examples/js/loaders/DRACOLoader.js"></script>
  <script src="https://unpkg.com/three@0.175.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://unpkg.com/dat.gui@0.7.9/build/dat.gui.min.js"></script>

  <script>
    // Log startup info with timestamp for debugging
    console.log('Starting Dragon Knight application');
    
    // Using hosted 3D models from reliable CDN services
    const MODELS = {
      dragon: 'https://models.readyplayer.me/64fa0336d1a68dae71a2c86e.glb',
      knight: 'https://market-assets.fra1.cdn.digitaloceanspaces.com/market-assets/models/knight/model.gltf',
      temple: 'https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/aztec-temple/model.gltf',
      skyHDR: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr'
    };

    // Wait for DOM to be ready
    window.addEventListener('DOMContentLoaded', function() {
      let scene, camera, renderer, controls;
      const loadingManager = new THREE.LoadingManager();
      const progressBar = document.getElementById('progress-bar');
      const loadingStatus = document.getElementById('loading-status');
      
      // Set up loading manager
      loadingManager.onProgress = function(url, loaded, total) {
        const percent = (loaded / total) * 100;
        progressBar.value = percent;
        loadingStatus.textContent = 'Loading: ' + url.split('/').pop() + ' (' + Math.round(percent) + '%)';
      };
      
      loadingManager.onLoad = function() {
        document.getElementById('loading').style.display = 'none';
        console.log('All resources loaded successfully');
      };
      
      loadingManager.onError = function(url) {
        console.error('Error loading: ' + url);
        loadingStatus.textContent = 'Error loading: ' + url.split('/').pop();
        // Show detailed error in browser console
        console.trace('Detailed error stack for: ' + url);
      };

      // Initialize the scene
      init();
      
      // Load models
      loadModels();
      
      // Start animation loop
      animate();
      
      function init() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // Camera setup
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 40);
        
        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);
        
        // Controls setup
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.enableZoom = true;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Load HDR environment map
        new THREE.RGBELoader(loadingManager)
          .load(MODELS.skyHDR, function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = texture;
            console.log('HDR environment loaded successfully');
          });
        
        // Add ground plane
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x333333,
          roughness: 0.8,
          metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -20;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);
      }
      
      function loadModels() {
        // GLTF loader setup
        const loader = new THREE.GLTFLoader(loadingManager);
        
        // Setup Draco loader for compressed models
        const dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.175.0/examples/js/libs/draco/');
        loader.setDRACOLoader(dracoLoader);
        
        // Load dragon (using a public dragon model)
        loadingStatus.textContent = 'Loading dragon...';
        loader.load(MODELS.dragon, function(gltf) {
          const model = gltf.scene;
          model.scale.set(5, 5, 5);
          model.position.set(0, -10, 5);
          model.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(model);
          console.log('Dragon loaded successfully');
        }, 
        // Progress callback
        function(xhr) {
          console.log('Dragon: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
        },
        // Error callback  
        function(error) {
          console.error('Error loading dragon:', error);
        });
        
        // Load knight (using a public knight model)
        loadingStatus.textContent = 'Loading knight...';
        loader.load(MODELS.knight, function(gltf) {
          const model = gltf.scene;
          model.scale.set(5, 5, 5);
          model.position.set(0, -10, 20);
          model.rotation.y = Math.PI; // Face the dragon
          model.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(model);
          console.log('Knight loaded successfully');
        },
        // Progress callback
        function(xhr) {
          console.log('Knight: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
        },
        // Error callback
        function(error) {
          console.error('Error loading knight:', error);
        });
        
        // Load temple (using a public temple model)
        loadingStatus.textContent = 'Loading temple...';
        loader.load(MODELS.temple, function(gltf) {
          const model = gltf.scene;
          model.scale.set(8, 8, 8);
          model.position.set(0, -20, 0);
          model.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(model);
          console.log('Temple loaded successfully');
        }, 
        // Progress callback
        function(xhr) {
          console.log('Temple: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
        },
        // Error callback
        function(error) {
          console.error('Error loading temple:', error);
        });
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
    });
  </script>
</body>
</html>